<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ïã§ÏãúÍ∞Ñ ÏãúÎÇòÎ¶¨Ïò§Î≥Ñ STT ÌÖåÏä§Ìä∏</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }
        
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
        }
        
        .scenario-section {
            margin-bottom: 30px;
        }
        
        .scenario-tabs {
            display: flex;
            margin-bottom: 20px;
        }
        
        .tab-button {
            padding: 12px 24px;
            margin-right: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .tab-button.dating {
            background: #ff6b9d;
            color: white;
        }
        
        .tab-button.interview {
            background: #4ecdc4;
            color: white;
        }
        
        .tab-button.presentation {
            background: #45b7d1;
            color: white;
        }
        
        .tab-button.active {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .controls {
            margin-bottom: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: inline-block;
            width: 120px;
            font-weight: bold;
            color: #4a5568;
        }
        
        select, input {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
        }
        
        button {
            padding: 12px 24px;
            margin: 5px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn-start {
            background: #48bb78;
            color: white;
        }
        
        .btn-stop {
            background: #f56565;
            color: white;
        }
        
        .btn-upload {
            background: #ed8936;
            color: white;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .status.connected {
            background: #c6f6d5;
            color: #22543d;
            border: 2px solid #48bb78;
        }
        
        .status.disconnected {
            background: #fed7d7;
            color: #742a2a;
            border: 2px solid #f56565;
        }
        
        .status.recording {
            background: #fef5e7;
            color: #744210;
            border: 2px solid #ed8936;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .results {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            min-height: 100px;
        }
        
        .transcription {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #4c51bf;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #4c51bf;
        }
        
        .metric-label {
            font-size: 12px;
            color: #718096;
            margin-top: 5px;
        }
        
        .speed-category {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .speed-very-slow { background: #fed7d7; color: #742a2a; }
        .speed-slow { background: #fef5e7; color: #744210; }
        .speed-normal { background: #c6f6d5; color: #22543d; }
        .speed-fast { background: #bee3f8; color: #2a4365; }
        .speed-very-fast { background: #e9d8fd; color: #44337a; }
        
        .permission-section, .connection-section, .recording-section {
            padding: 15px;
            border-radius: 8px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            margin-bottom: 15px;
        }
        
        .permission-section {
            border-left: 4px solid #ffc107;
        }
        
        .connection-section {
            border-left: 4px solid #17a2b8;
        }
        
        .recording-section {
            border-left: 4px solid #28a745;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
        }
        
        .visualizer {
            height: 120px;
            background: linear-gradient(45deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #e9ecef;
            border-radius: 12px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .visualizer canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .log-section {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .log-entry {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .log-send {
            color: #dc3545;
            font-weight: bold;
        }
        
        .log-receive {
            color: #28a745;
            font-weight: bold;
        }
        
        .log-info {
            color: #17a2b8;
        }
        
        .buffer-status {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 8px 12px;
            margin: 10px 0;
            font-size: 12px;
            color: #856404;
        }
        
        .interim {
            color: #888;
            font-style: italic;
        }
        
        .final {
            color: #000;
        }
        
        .segment {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 4px;
        }
        
        .segment.new {
            background-color: #f1f8e9;
            animation: fadeIn 1s;
        }
        
        @keyframes fadeIn {
            from { background-color: #c8e6c9; }
            to { background-color: #f1f8e9; }
        }
        
        .upload-section {
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéôÔ∏è Ïã§ÏãúÍ∞Ñ ÏãúÎÇòÎ¶¨Ïò§Î≥Ñ STT ÌÖåÏä§Ìä∏</h1>
        
        <div class="scenario-section">
            <div class="scenario-tabs">
                <button class="tab-button dating active" data-scenario="dating">
                    üíï ÏÜåÍ∞úÌåÖ
                </button>
                <button class="tab-button interview" data-scenario="interview">
                    üíº Î©¥Ï†ë
                </button>
                <button class="tab-button presentation" data-scenario="presentation">
                    üìä Î∞úÌëú
                </button>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>Ïñ∏Ïñ¥:</label>
                    <select id="languageSelect">
                        <option value="ko">ÌïúÍµ≠Ïñ¥</option>
                        <option value="en">English</option>
                        <option value="ja">Êó•Êú¨Ë™û</option>
                        <option value="zh">‰∏≠Êñá</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>ÏÑúÎ≤Ñ URL:</label>
                    <input type="text" id="serverUrl" value="wss://stt.eumgyeol.com/api/v1/stt/stream" style="width: 300px;">
                </div>
            </div>
            
            <!-- Ïã§ÏãúÍ∞Ñ Ïä§Ìä∏Î¶¨Î∞ç ÏÑπÏÖò -->
            <div>
                <h3>üî¥ Ïã§ÏãúÍ∞Ñ ÏùåÏÑ± Ïù∏Ïãù</h3>
                
                <!-- ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÏÑπÏÖò -->
                <div class="permission-section">
                    <div class="section-title">üé§ 1Îã®Í≥Ñ: ÎßàÏù¥ÌÅ¨ Í∂åÌïú</div>
                    <button id="micPermissionBtn" class="btn-start">ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÏöîÏ≤≠</button>
                    <span id="micStatus" style="margin-left: 10px; font-size: 12px; color: #666;">ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÌïÑÏöî</span>
                </div>
                
                <!-- ÏõπÏÜåÏºì Ïó∞Í≤∞ ÏÑπÏÖò -->
                <div class="connection-section">
                    <div class="section-title">üîó 2Îã®Í≥Ñ: ÏÑúÎ≤Ñ Ïó∞Í≤∞</div>
                    <button id="connectBtn" class="btn-start" disabled>ÏÑúÎ≤Ñ Ïó∞Í≤∞</button>
                    <button id="disconnectBtn" class="btn-stop" disabled>Ïó∞Í≤∞ Ìï¥Ï†ú</button>
                    <span id="connectionStatus" style="margin-left: 10px; font-size: 12px; color: #666;">Ïó∞Í≤∞ ÏïàÎê®</span>
                </div>
                
                <!-- ÎÖπÏùå Ï†úÏñ¥ ÏÑπÏÖò -->
                <div class="recording-section">
                    <div class="section-title">üéôÔ∏è 3Îã®Í≥Ñ: ÏùåÏÑ± ÎÖπÏùå</div>
                    <button id="startRecordingBtn" class="btn-start" disabled>ÎÖπÏùå ÏãúÏûë</button>
                    <button id="stopRecordingBtn" class="btn-stop" disabled>ÎÖπÏùå Ï§ëÏßÄ</button>
                    <br><br>
                    <div style="border-top: 1px solid #dee2e6; padding-top: 10px; margin-top: 10px;">
                        <div class="section-title">‚ö° Îπ†Î•∏ ÏãúÏûë</div>
                        <button id="quickStartBtn" class="btn-upload">ÏõêÌÅ¥Î¶≠ ÏãúÏûë (Î™®Îì† Îã®Í≥Ñ ÏûêÎèô)</button>
                    </div>
                </div>
                
                <!-- Ïò§ÎîîÏò§ ÏãúÍ∞ÅÌôî ÏÑπÏÖò -->
                <div class="visualizer">
                    <canvas id="audio-visualizer"></canvas>
                </div>
                
                <!-- Î≤ÑÌçº ÏÉÅÌÉú ÌëúÏãú -->
                <div id="bufferStatus" class="buffer-status" style="display: none;">
                    Î≤ÑÌçºÎßÅ Ï§ë: <span id="bufferProgress">0/30</span>Ï¥à (<span id="bufferSize">0</span>KB)
                </div>
                
                <!-- Ïò§ÎîîÏò§ ÏÜ°ÏàòÏã† Î°úÍ∑∏ -->
                <div class="log-section">
                    <div style="font-weight: bold; margin-bottom: 8px;">üìä Ïò§ÎîîÏò§ ÏÜ°ÏàòÏã† Î°úÍ∑∏</div>
                    <div id="audioLog"></div>
                </div>
                
                <div id="status" class="status disconnected">Ï§ÄÎπÑ Ï§ë...</div>
            </div>
            
            <!-- ÌååÏùº ÏóÖÎ°úÎìú ÏÑπÏÖò -->
            <div class="upload-section">
                <h3>üìÅ ÌååÏùº ÏóÖÎ°úÎìú ÌÖåÏä§Ìä∏</h3>
                <input type="file" id="fileInput" accept=".wav,.mp3,.ogg,.flac">
                <button id="uploadBtn" class="btn-upload">ÌååÏùº Î∂ÑÏÑù</button>
            </div>
        </div>
        
        <div class="results" id="results">
            <h3>üìä Î∂ÑÏÑù Í≤∞Í≥º</h3>
            <div id="transcriptions"></div>
        </div>
    </div>

    <script>
        class RealtimeSTTClient {
            constructor() {
                this.ws = null;
                this.mediaStream = null;
                this.audioContext = null;
                this.processor = null;
                this.analyser = null;
                this.dataArray = null;
                this.animationId = null;
                
                this.currentScenario = 'dating';
                this.isRecording = false;
                this.isConnected = false;
                this.hasMicPermission = false;
                
                // 60Ï¥à Î≤ÑÌçºÎßÅÏùÑ ÏúÑÌïú Î≥ÄÏàòÎì§
                this.audioBuffer = [];
                this.audioBufferDuration = 0;
                this.bufferStartTime = null;
                this.bufferDuration = 30; // 60Ï¥à
                this.totalAudioSent = 0;
                this.totalAudioReceived = 0;
                
                this.initializeUI();
                this.checkMicPermission();
            }
            
            initializeUI() {
                // ÏãúÎÇòÎ¶¨Ïò§ ÌÉ≠ Ïù¥Î≤§Ìä∏
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentScenario = e.target.dataset.scenario;
                        console.log('ÏãúÎÇòÎ¶¨Ïò§ Î≥ÄÍ≤Ω:', this.currentScenario);
                    });
                });
                
                // ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÏöîÏ≤≠ Î≤ÑÌäº
                document.getElementById('micPermissionBtn').addEventListener('click', () => this.requestMicPermission());
                
                // ÏõπÏÜåÏºì Ïó∞Í≤∞ Î≤ÑÌäº
                document.getElementById('connectBtn').addEventListener('click', () => this.connectWebSocket());
                document.getElementById('disconnectBtn').addEventListener('click', () => this.disconnectWebSocket());
                
                // ÎÖπÏùå Ï†úÏñ¥ Î≤ÑÌäº
                document.getElementById('startRecordingBtn').addEventListener('click', () => this.startRecording());
                document.getElementById('stopRecordingBtn').addEventListener('click', () => this.stopRecording());
                document.getElementById('quickStartBtn').addEventListener('click', () => this.quickStart());
                
                // ÌååÏùº ÏóÖÎ°úÎìú Ïù¥Î≤§Ìä∏
                document.getElementById('uploadBtn').addEventListener('click', () => this.uploadFile());
            }
            
            async checkMicPermission() {
                try {
                    const result = await navigator.permissions.query({ name: 'microphone' });
                    if (result.state === 'granted') {
                        this.setMicPermission(true);
                    } else {
                        this.setMicPermission(false);
                    }
                    
                    result.addEventListener('change', () => {
                        this.setMicPermission(result.state === 'granted');
                    });
                } catch (error) {
                    console.log('Í∂åÌïú API ÎØ∏ÏßÄÏõê, ÏàòÎèô ÌôïÏù∏ ÌïÑÏöî');
                    this.setMicPermission(false);
                }
            }
            
            setMicPermission(hasPermission) {
                this.hasMicPermission = hasPermission;
                const micStatus = document.getElementById('micStatus');
                const connectBtn = document.getElementById('connectBtn');
                
                if (hasPermission) {
                    micStatus.textContent = '‚úÖ ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÏûàÏùå';
                    micStatus.style.color = '#22543d';
                    connectBtn.disabled = false;
                } else {
                    micStatus.textContent = '‚ùå ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÌïÑÏöî';
                    micStatus.style.color = '#742a2a';
                    connectBtn.disabled = true;
                }
                
                this.updateButtonStates();
            }
            
            async requestMicPermission() {
                try {
                    this.updateStatus('recording', 'ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÏöîÏ≤≠ Ï§ë...');
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    
                    // Ïä§Ìä∏Î¶ºÏùÑ Ï¶âÏãú Ï¢ÖÎ£å (Í∂åÌïú ÌôïÏù∏Ïö©)
                    stream.getTracks().forEach(track => track.stop());
                    
                    this.setMicPermission(true);
                    this.updateStatus('connected', 'ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÌöçÎìù ÏôÑÎ£å');
                    
                } catch (error) {
                    console.error('ÎßàÏù¥ÌÅ¨ Í∂åÌïú Í±∞Î∂Ä:', error);
                    this.setMicPermission(false);
                    this.updateStatus('disconnected', 'ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§');
                    alert('ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§. Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ïÏóêÏÑú ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏùÑ ÌóàÏö©Ìï¥Ï£ºÏÑ∏Ïöî.');
                }
            }
            
            connectWebSocket() {
                if (this.isConnected) {
                    this.updateStatus('connected', 'Ïù¥ÎØ∏ Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÏäµÎãàÎã§');
                    return;
                }
                
                const language = document.getElementById('languageSelect').value;
                const serverUrl = document.getElementById('serverUrl').value;
                const wsUrl = `${serverUrl}?language=${language}&scenario=${this.currentScenario}`;
                
                this.updateStatus('recording', 'ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ï§ë...');
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('WebSocket Ïó∞Í≤∞Îê®');
                    this.addLog('info', `ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÑ±Í≥µ: ${wsUrl}`);
                    this.isConnected = true;
                    this.setConnectionStatus(true);
                    this.updateStatus('connected', 'ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏôÑÎ£å');
                    this.updateButtonStates();
                    
                    // Ïó∞Í≤∞ ÏÉÅÌÉú ÎîîÎ≤ÑÍπÖ Ï†ïÎ≥¥
                    this.addLog('info', `ÏõπÏÜåÏºì ÏÉÅÌÉú: ${this.ws.readyState}, ÌîÑÎ°úÌÜ†ÏΩú: ${this.ws.protocol}`);
                };
                
                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.totalAudioReceived += event.data.length;
                    this.addLog('receive', `STT Í≤∞Í≥º ÏàòÏã†: "${data.text?.substring(0, 50)}${data.text?.length > 50 ? '...' : ''}" | Ï¥ù ÏàòÏã†: ${(this.totalAudioReceived / 1024).toFixed(1)}KB`);
                    this.handleWebSocketMessage(data);
                };
                
                this.ws.onclose = () => {
                    console.log('WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å');
                    this.addLog('info', 'WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å');
                    this.isConnected = false;
                    this.setConnectionStatus(false);
                    this.updateStatus('disconnected', 'ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ï¢ÖÎ£å');
                    this.updateButtonStates();
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket Ïò§Î•ò:', error);
                    this.addLog('info', 'WebSocket Ïó∞Í≤∞ Ïò§Î•ò');
                    this.isConnected = false;
                    this.setConnectionStatus(false);
                    this.updateStatus('disconnected', 'ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•ò');
                    this.updateButtonStates();
                };
            }
            
            disconnectWebSocket() {
                if (this.isRecording) {
                    this.stopRecording();
                }
                
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                
                this.isConnected = false;
                this.setConnectionStatus(false);
                this.updateStatus('disconnected', 'ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ìï¥Ï†úÎê®');
                this.updateButtonStates();
            }
            
            setConnectionStatus(isConnected) {
                const connectionStatus = document.getElementById('connectionStatus');
                
                if (isConnected) {
                    connectionStatus.textContent = '‚úÖ ÏÑúÎ≤Ñ Ïó∞Í≤∞Îê®';
                    connectionStatus.style.color = '#22543d';
                } else {
                    connectionStatus.textContent = '‚ùå ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏïàÎê®';
                    connectionStatus.style.color = '#742a2a';
                }
            }
            
            async startRecording() {
                if (!this.isConnected) {
                    alert('Î®ºÏ†Ä ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞Ìï¥Ï£ºÏÑ∏Ïöî.');
                    return;
                }
                
                if (this.isRecording) {
                    this.updateStatus('recording', 'Ïù¥ÎØ∏ ÎÖπÏùå Ï§ëÏûÖÎãàÎã§');
                    return;
                }
                
                try {
                    this.updateStatus('recording', 'ÎßàÏù¥ÌÅ¨ ÌôúÏÑ±Ìôî Ï§ë...');
                    
                    // ÎßàÏù¥ÌÅ¨ Ïä§Ìä∏Î¶º ÏÉùÏÑ±
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    
                    // AudioContext ÏÑ§Ï†ï
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = this.audioContext.createMediaStreamSource(this.mediaStream);
                    
                    // Ïã§ÏãúÍ∞Ñ Ïò§ÎîîÏò§ Ï≤òÎ¶¨Î•º ÏúÑÌïú ScriptProcessor
                    this.processor = this.audioContext.createScriptProcessor(4096, 1, 1);
                    
                    this.processor.onaudioprocess = (event) => {
                        if (!this.isRecording) return;
                        
                        const inputBuffer = event.inputBuffer;
                        const inputData = inputBuffer.getChannelData(0);
                        
                        // 16kHzÎ°ú Îã§Ïö¥ÏÉòÌîåÎßÅ (Whisper Î™®Îç∏ ÏöîÍµ¨ÏÇ¨Ìï≠)
                        const targetSampleRate = 16000;
                        const resampledData = this.downsampleAudio(inputData, this.audioContext.sampleRate, targetSampleRate);
                            
                        // Float32ArrayÎ•º Int16ArrayÎ°ú Î≥ÄÌôò (16-bit PCM)
                        const pcmData = this.convertFloatTo16BitPCM(resampledData);
                        
                        // 60Ï¥à Î≤ÑÌçºÏóê Ï∂îÍ∞Ä
                        this.addToBuffer(pcmData, resampledData.length / targetSampleRate);
                        
                        // Î≤ÑÌçº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                        this.updateBufferStatus();
                    };
                    
                    source.connect(this.processor);
                    this.processor.connect(this.audioContext.destination);
                    
                    // Ïò§ÎîîÏò§ ÏãúÍ∞ÅÌôî ÏÑ§Ï†ï
                    this.setupAudioVisualization(source);
                    
                    this.isRecording = true;
                    
                    // ÏÑúÎ≤ÑÏóê ÎÖπÏùå ÏãúÏûë Î™ÖÎ†π Ï†ÑÏÜ°
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({command: "start_recording"}));
                        this.addLog('send', 'ÎÖπÏùå ÏãúÏûë Î™ÖÎ†π Ï†ÑÏÜ°');
                    }
                    
                    this.updateStatus('recording', 'ÎÖπÏùå Ï§ë...');
                    this.updateButtonStates();
                    
                } catch (error) {
                    console.error('ÎÖπÏùå ÏãúÏûë Ïò§Î•ò:', error);
                    this.updateStatus('disconnected', 'ÎÖπÏùå ÏãúÏûë Ïã§Ìå®');
                    alert('ÎßàÏù¥ÌÅ¨ Ï†ëÍ∑ºÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message);
                }
            }
            
            setupAudioVisualization(source) {
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 256;
                const bufferLength = this.analyser.frequencyBinCount;
                this.dataArray = new Uint8Array(bufferLength);
                
                source.connect(this.analyser);
                this.startVisualization();
            }
            
            startVisualization() {
                const canvas = document.getElementById('audio-visualizer');
                if (!canvas || !this.analyser) return;
                
                const canvasCtx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                let animationTime = 0;
                
                const draw = () => {
                    if (!this.isRecording) return;
                    
                    this.animationId = requestAnimationFrame(draw);
                    animationTime += 0.1;
                    
                    this.analyser.getByteFrequencyData(this.dataArray);
                    
                    // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Î∞∞Í≤Ω
                    const gradient = canvasCtx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#667eea');
                    gradient.addColorStop(1, '#764ba2');
                    canvasCtx.fillStyle = gradient;
                    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const barWidth = (canvas.width / this.dataArray.length) * 3;
                    let x = 0;
                    
                    for (let i = 0; i < this.dataArray.length; i++) {
                        const barHeight = (this.dataArray[i] / 255) * canvas.height * 0.8;
                        
                        // Î¨¥ÏßÄÍ∞ú ÏÉâÏÉÅ Ìö®Í≥º
                        const hue = (i / this.dataArray.length) * 360 + animationTime * 2;
                        const saturation = 70 + (this.dataArray[i] / 255) * 30;
                        const lightness = 50 + (this.dataArray[i] / 255) * 40;
                        
                        canvasCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                        
                        // Îë•Í∑º Î™®ÏÑúÎ¶¨ Ìö®Í≥º
                        canvasCtx.beginPath();
                        canvasCtx.roundRect(x, canvas.height - barHeight, barWidth - 2, barHeight, 3);
                        canvasCtx.fill();
                        
                        // Î∞úÍ¥ë Ìö®Í≥º
                        canvasCtx.shadowColor = canvasCtx.fillStyle;
                        canvasCtx.shadowBlur = 10;
                        canvasCtx.fill();
                        canvasCtx.shadowBlur = 0;
                        
                        x += barWidth;
                    }
                    
                    // ÏÉÅÎã®Ïóê ÌååÌòï Ïò§Î≤ÑÎ†àÏù¥
                    this.analyser.getByteTimeDomainData(this.dataArray);
                    canvasCtx.strokeStyle = '#ffffff';
                    canvasCtx.lineWidth = 2;
                    canvasCtx.beginPath();
                    
                    const sliceWidth = canvas.width / this.dataArray.length;
                    x = 0;
                    
                    for (let i = 0; i < this.dataArray.length; i++) {
                        const v = this.dataArray[i] / 128.0;
                        const y = v * canvas.height / 4 + canvas.height / 8;
                        
                        if (i === 0) {
                            canvasCtx.moveTo(x, y);
                        } else {
                            canvasCtx.lineTo(x, y);
                        }
                        
                        x += sliceWidth;
                    }
                    
                    canvasCtx.stroke();
                };
                
                draw();
            }
            
            stopRecording() {
                if (!this.isRecording) {
                    this.updateStatus('connected', 'ÎÖπÏùå Ï§ëÏù¥ ÏïÑÎãôÎãàÎã§');
                    return;
                }
                
                this.isRecording = false;
                
                // ÎÇ®ÏùÄ Î≤ÑÌçº Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ° (ÎÖπÏùå Ï§ëÏßÄ Î™ÖÎ†π Ï†ÑÏóê)
                this.sendBufferedAudio(true);
                
                // ÏÑúÎ≤ÑÏóê ÎÖπÏùå Ï§ëÏßÄ Î™ÖÎ†π Ï†ÑÏÜ° (Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ° ÌõÑ)
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({command: "stop_recording"}));
                    this.addLog('send', 'ÎÖπÏùå Ï§ëÏßÄ Î™ÖÎ†π Ï†ÑÏÜ°');
                }
                
                // ÏãúÍ∞ÅÌôî Ï†ïÏßÄ
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                // AudioContext Ï†ïÎ¶¨
                if (this.processor) {
                    this.processor.disconnect();
                    this.processor = null;
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                // ÎØ∏ÎîîÏñ¥ Ïä§Ìä∏Î¶º Ï†ïÏßÄ
                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }
                
                // Ï∫îÎ≤ÑÏä§ Ï¥àÍ∏∞Ìôî
                const canvas = document.getElementById('audio-visualizer');
                if (canvas) {
                    const canvasCtx = canvas.getContext('2d');
                    const gradient = canvasCtx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#f8f9fa');
                    gradient.addColorStop(1, '#e9ecef');
                    canvasCtx.fillStyle = gradient;
                    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
                }
                
                // Î≤ÑÌçº ÏÉÅÌÉú Ïà®ÍπÄ
                document.getElementById('bufferStatus').style.display = 'none';
                
                // ÏµúÏ¢Ö Ï≤òÎ¶¨ ÏöîÏ≤≠
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({command: "process_final"}));
                    this.addLog('send', 'ÏµúÏ¢Ö Ï≤òÎ¶¨ ÏöîÏ≤≠ Ï†ÑÏÜ°');
                }
                
                this.updateStatus('connected', 'ÎÖπÏùå ÏôÑÎ£å');
                this.updateButtonStates();
            }
            
            addToBuffer(pcmData, audioDuration) {
                if (!this.bufferStartTime) {
                    this.bufferStartTime = Date.now();
                    this.audioBufferDuration = 0;
                    document.getElementById('bufferStatus').style.display = 'block';
                    this.addLog('info', `30Ï¥à Î≤ÑÌçºÎßÅ ÏãúÏûë - PCM Î∞∞Ïó¥ Í∏∏Ïù¥: ${pcmData.length}, Ïò§ÎîîÏò§ Í∏∏Ïù¥: ${audioDuration.toFixed(3)}Ï¥à`);
                }
                
                this.audioBuffer.push(pcmData);
                this.audioBufferDuration += audioDuration;
                
                // ÎîîÎ≤ÑÍπÖÏö© Î°úÍ∑∏ (Îß§ 100Í∞ú chunkÎßàÎã§)
                if (this.audioBuffer.length % 100 === 0) {
                    this.addLog('info', `Î≤ÑÌçº ÏÉÅÌÉú: ${this.audioBuffer.length}Í∞ú Ï≤≠ÌÅ¨, Ï¥ù ${this.audioBufferDuration.toFixed(1)}Ï¥à`);
                }
                
                // Ïò§ÎîîÏò§ Í∏∞Ï§Ä 30Ï¥àÍ∞Ä ÎêòÎ©¥ Ï†ÑÏÜ°
                if (this.audioBufferDuration >= this.bufferDuration) {
                    this.sendBufferedAudio();
                }
            }
            
            downsampleAudio(audioBuffer, sourceSampleRate, targetSampleRate) {
                if (sourceSampleRate === targetSampleRate) {
                    return audioBuffer;
                }
                
                const ratio = sourceSampleRate / targetSampleRate;
                const newLength = Math.round(audioBuffer.length / ratio);
                const result = new Float32Array(newLength);
                
                // Îã®ÏàúÌïú ÏÑ†Ìòï Î≥¥Í∞ÑÏùÑ ÏÇ¨Ïö©Ìïú Îã§Ïö¥ÏÉòÌîåÎßÅ
                for (let i = 0; i < newLength; i++) {
                    const position = i * ratio;
                    const index = Math.floor(position);
                    const fraction = position - index;
                    
                    // ÏÑ†Ìòï Î≥¥Í∞Ñ
                    if (index + 1 < audioBuffer.length) {
                        result[i] = audioBuffer[index] * (1 - fraction) + audioBuffer[index + 1] * fraction;
                    } else {
                        result[i] = audioBuffer[index];
                    }
                }
                
                return result;
            }
            
            convertFloatTo16BitPCM(float32Array) {
                const l = float32Array.length;
                const pcm16bit = new Int16Array(l);
                
                for (let i = 0; i < l; i++) {
                    // ÌÅ¥Î¶¨Ìïë Î∞©ÏßÄ
                    const s = Math.max(-1, Math.min(1, float32Array[i]));
                    // -32768 ~ 32767 Î≤îÏúÑÎ°ú Î≥ÄÌôò
                    pcm16bit[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }
                
                return pcm16bit;
            }
            
            sendBufferedAudio(isFinal = false) {
                if (this.audioBuffer.length === 0) return;
                
                // WebSocketÏúºÎ°ú Ï†ÑÏÜ° - Int16Array Î∞∞Ïó¥ÏùÑ ÌïòÎÇòÏùò ArrayBufferÎ°ú Ìï©ÏπòÍ∏∞
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    // Î™®Îì† Int16Array Î∞∞Ïó¥Ïùò Ï¥ù Í∏∏Ïù¥ Í≥ÑÏÇ∞
                    const totalLength = this.audioBuffer.reduce((sum, buffer) => sum + buffer.length, 0);
                    
                    // ÏÉàÎ°úÏö¥ Int16Array ÏÉùÏÑ±ÌïòÏó¨ Î™®Îì† Îç∞Ïù¥ÌÑ∞ Ìï©ÏπòÍ∏∞
                    const combinedArray = new Int16Array(totalLength);
                    let offset = 0;
                    
                    for (const buffer of this.audioBuffer) {
                        combinedArray.set(buffer, offset);
                        offset += buffer.length;
                    }
                    
                    // ArrayBufferÎ°ú Î≥ÄÌôòÌïòÏó¨ Ï†ÑÏÜ°
                    const audioData = combinedArray.buffer;
                    this.ws.send(audioData);
                    
                    const sizeKB = (audioData.byteLength / 1024).toFixed(1);
                    const duration = this.audioBufferDuration.toFixed(1);
                    this.totalAudioSent += audioData.byteLength;
                    
                    this.addLog('send', `Ïò§ÎîîÏò§ Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°: ${duration}Ï¥à (${sizeKB}KB, ${totalLength} samples) | Ï¥ù Ï†ÑÏÜ°: ${(this.totalAudioSent / 1024 / 1024).toFixed(1)}MB`);
                }
                
                // Î≤ÑÌçº Ï¥àÍ∏∞Ìôî
                this.audioBuffer = [];
                this.audioBufferDuration = 0;
                this.bufferStartTime = isFinal ? null : Date.now();
                
                if (!isFinal) {
                    this.addLog('info', 'ÏÉàÎ°úÏö¥ 30Ï¥à Î≤ÑÌçºÎßÅ ÏãúÏûë');
                }
            }
            
            updateBufferStatus() {
                if (!this.bufferStartTime) return;
                
                const progress = Math.min(this.audioBufferDuration, this.bufferDuration);
                const totalBytes = this.audioBuffer.reduce((sum, buffer) => sum + buffer.byteLength, 0);
                const sizeKB = (totalBytes / 1024).toFixed(1);
                
                document.getElementById('bufferProgress').textContent = `${progress.toFixed(1)}/${this.bufferDuration}`;
                document.getElementById('bufferSize').textContent = sizeKB;
            }
            
            addLog(type, message) {
                const logContainer = document.getElementById('audioLog');
                const timestamp = new Date().toLocaleTimeString();
                
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                
                let prefix = '';
                switch(type) {
                    case 'send': prefix = 'üì§ '; break;
                    case 'receive': prefix = 'üì• '; break;
                    case 'info': prefix = '‚ÑπÔ∏è '; break;
                }
                
                logEntry.textContent = `[${timestamp}] ${prefix}${message}`;
                logContainer.appendChild(logEntry);
                
                // Ïä§ÌÅ¨Î°§ÏùÑ Îß® ÏïÑÎûòÎ°ú
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // ÏµúÎåÄ 100Í∞ú Î°úÍ∑∏Îßå Ïú†ÏßÄ
                while (logContainer.children.length > 100) {
                    logContainer.removeChild(logContainer.firstChild);
                }
            }
            
            async quickStart() {
                try {
                    // ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÌôïÏù∏
                    if (!this.hasMicPermission) {
                        await this.requestMicPermission();
                        if (!this.hasMicPermission) {
                            return;
                        }
                    }
                    
                    // ÏõπÏÜåÏºì Ïó∞Í≤∞
                    if (!this.isConnected) {
                        await new Promise((resolve, reject) => {
                            this.connectWebSocket();
                            
                            const checkConnection = () => {
                                if (this.isConnected) {
                                    resolve();
                                } else if (this.ws && this.ws.readyState === WebSocket.CLOSED) {
                                    reject(new Error('Ïó∞Í≤∞ Ïã§Ìå®'));
                                } else {
                                    setTimeout(checkConnection, 100);
                                }
                            };
                            
                            setTimeout(checkConnection, 100);
                            setTimeout(() => reject(new Error('Ïó∞Í≤∞ ÏãúÍ∞Ñ Ï¥àÍ≥º')), 5000);
                        });
                    }
                    
                    // ÎÖπÏùå ÏãúÏûë
                    await this.startRecording();
                    
                } catch (error) {
                    console.error('ÏõêÌÅ¥Î¶≠ ÏãúÏûë Ïò§Î•ò:', error);
                    this.updateStatus('disconnected', 'ÏõêÌÅ¥Î¶≠ ÏãúÏûë Ïã§Ìå®: ' + error.message);
                }
            }
            
            updateButtonStates() {
                // ÎßàÏù¥ÌÅ¨ Í∂åÌïú Î≤ÑÌäº
                const micPermissionBtn = document.getElementById('micPermissionBtn');
                micPermissionBtn.disabled = this.hasMicPermission;
                
                // ÏõπÏÜåÏºì Ïó∞Í≤∞ Î≤ÑÌäº
                const connectBtn = document.getElementById('connectBtn');
                const disconnectBtn = document.getElementById('disconnectBtn');
                connectBtn.disabled = !this.hasMicPermission || this.isConnected;
                disconnectBtn.disabled = !this.isConnected;
                
                // ÎÖπÏùå Î≤ÑÌäº
                const startRecordingBtn = document.getElementById('startRecordingBtn');
                const stopRecordingBtn = document.getElementById('stopRecordingBtn');
                const quickStartBtn = document.getElementById('quickStartBtn');
                
                startRecordingBtn.disabled = !this.isConnected || this.isRecording;
                stopRecordingBtn.disabled = !this.isRecording;
                quickStartBtn.disabled = this.isRecording;
            }
            
            handleWebSocketMessage(data) {
                console.log('ÏàòÏã† Îç∞Ïù¥ÌÑ∞:', data);
                
                if (data.type === 'transcription') {
                    this.displayTranscription(data);
                } else if (data.type === 'connected') {
                    console.log('Ïó∞Í≤∞ ÌôïÏù∏:', data.message);
                } else if (data.type === 'error') {
                    console.error('ÏÑúÎ≤Ñ Ïò§Î•ò:', data.message);
                    alert('ÏÑúÎ≤Ñ Ïò§Î•ò: ' + data.message);
                }
            }
            
            displayTranscription(data) {
                const container = document.getElementById('transcriptions');
                
                const transcDiv = document.createElement('div');
                transcDiv.className = 'transcription';
                
                const speedClass = `speed-${data.speech_metrics?.speed_category || 'normal'}`;
                const patternLabel = this.getSpeechPatternLabel(data.speech_metrics?.speech_pattern);
                
                // Í∞êÏ†ïÎ∂ÑÏÑù Í≤∞Í≥º HTML ÏÉùÏÑ±
                let emotionHtml = '';
                if (data.emotion_analysis) {
                    const primaryEmotion = data.emotion_analysis.primary_emotion;
                    const allEmotions = data.emotion_analysis.all_emotions || data.emotion_analysis.top_emotions;
                    
                    emotionHtml = `
                        <div style="margin-top: 10px; padding: 10px; background: #f0f9ff; border-left: 4px solid #0ea5e9; border-radius: 6px;">
                            <div style="margin-bottom: 8px;">
                                <strong>üòä Í∞êÏ†ïÎ∂ÑÏÑù:</strong> 
                                <span style="font-weight: bold; color: #0369a1;">${primaryEmotion.emotion_kr}</span>
                                <span style="margin-left: 8px; padding: 2px 6px; background: #bae6fd; border-radius: 8px; font-size: 11px; font-weight: bold;">
                                    ${(primaryEmotion.probability * 100).toFixed(1)}%
                                </span>
                            </div>
                            <div style="font-size: 12px; color: #475569; margin-bottom: 8px;">
                                <strong>Î™®Îì† Í∞êÏ†ï:</strong> ${allEmotions.map(e => 
                                    `${e.emotion_kr} (${(e.probability * 100).toFixed(1)}%)`
                                ).join(', ')}
                            </div>
                            <div style="font-size: 11px; color: #64748b; margin-top: 4px;">
                                Î™®Îç∏: ${data.emotion_analysis.model_used?.split('/').pop() || 'Ïïå Ïàò ÏóÜÏùå'} | 
                                Ï≤òÎ¶¨ÏãúÍ∞Ñ: ${(data.emotion_analysis.processing_time * 1000).toFixed(0)}ms |
                                ÏãúÎÇòÎ¶¨Ïò§ Í∞ÄÏ§ëÏπò: ${data.emotion_analysis.scenario_applied ? 'Ï†ÅÏö©' : 'ÎØ∏Ï†ÅÏö©'}
                            </div>
                        </div>
                    `;
                } else {
                    emotionHtml = `
                        <div style="margin-top: 10px; padding: 8px; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 6px;">
                            <span style="font-size: 12px; color: #92400e;">üòî Í∞êÏ†ïÎ∂ÑÏÑù Í≤∞Í≥º ÏóÜÏùå (ÏÑúÎπÑÏä§ Ïó∞Í≤∞ ÌôïÏù∏ ÌïÑÏöî)</span>
                        </div>
                    `;
                }
                
                transcDiv.innerHTML = `
                    <div>
                        <strong>üìù Ïù∏Ïãù Í≤∞Í≥º:</strong> ${data.text}
                        <span class="speed-category ${speedClass}">${this.getSpeedLabel(data.speech_metrics?.speed_category)}</span>
                        <span class="speech-pattern" style="margin-left: 10px; padding: 4px 8px; background: #e2e8f0; border-radius: 12px; font-size: 12px; font-weight: bold;">${patternLabel}</span>
                    </div>
                    ${emotionHtml}
                    <div style="margin-top: 10px; font-size: 12px; color: #666;">
                        ÏãúÎÇòÎ¶¨Ïò§: ${data.scenario} | Ïñ∏Ïñ¥: ${data.language} | ${data.is_final ? 'ÏµúÏ¢Ö' : 'Ï§ëÍ∞Ñ'} Í≤∞Í≥º
                        ${data.segments ? ` | ÏÑ∏Í∑∏Î®ºÌä∏ Ïàò: ${data.segments.length}` : ''}
                    </div>
                    ${this.renderMetrics(data.speech_metrics, data.syllable_metrics, data.variability_metrics, data.emotion_analysis)}
                `;
                
                container.appendChild(transcDiv);
                container.scrollTop = container.scrollHeight;
            }
            
            renderMetrics(speechMetrics, syllableMetrics, variabilityMetrics, emotionAnalysis) {
                if (!speechMetrics) return '';
                
                let emotionMetricsHtml = '';
                if (emotionAnalysis && (emotionAnalysis.all_emotions || emotionAnalysis.top_emotions)) {
                    const emotions = emotionAnalysis.all_emotions || emotionAnalysis.top_emotions;
                    emotionMetricsHtml = emotions.map(emotion => `
                        <div class="metric-card">
                            <div class="metric-value">${emotion.emotion_kr}</div>
                            <div class="metric-label">${(emotion.probability * 100).toFixed(1)}%</div>
                        </div>
                    `).join('');
                }
                
                return `
                    <div class="metrics">
                        <div class="metric-card">
                            <div class="metric-value">${speechMetrics.evaluation_wpm}</div>
                            <div class="metric-label">ÌèâÍ∞Ä WPM</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${speechMetrics.average_segment_wpm}</div>
                            <div class="metric-label">ÏÑ∏Í∑∏Î®ºÌä∏ ÌèâÍ∑† WPM</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${speechMetrics.median_segment_wpm}</div>
                            <div class="metric-label">ÏÑ∏Í∑∏Î®ºÌä∏ Ï§ëÏïôÍ∞í WPM</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${(speechMetrics.speech_density * 100).toFixed(1)}%</div>
                            <div class="metric-label">Î∞úÌôî Î∞ÄÎèÑ</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${speechMetrics.pause_metrics?.count || 0}</div>
                            <div class="metric-label">Pause ÌöüÏàò</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${speechMetrics.pause_metrics?.average_duration?.toFixed(2) || 0}Ï¥à</div>
                            <div class="metric-label">ÌèâÍ∑† Pause</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${this.getSpeechPatternLabel(speechMetrics.speech_pattern)}</div>
                            <div class="metric-label">ÎßêÌïòÍ∏∞ Ìå®ÌÑ¥</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${speechMetrics.wpm_cv || 0}</div>
                            <div class="metric-label">WPM Î≥ÄÎèôÏÑ±</div>
                        </div>
                        ${syllableMetrics ? `
                        <div class="metric-card">
                            <div class="metric-value">${syllableMetrics.spm_active}</div>
                            <div class="metric-label">SPM (Î∞úÌôîÏãú)</div>
                        </div>` : ''}
                        ${emotionMetricsHtml}
                    </div>
                `;
            }
            
            getSpeedLabel(category) {
                const labels = {
                    'very_slow': 'Îß§Ïö∞ ÎäêÎ¶º',
                    'slow': 'ÎäêÎ¶º',
                    'normal': 'Ï†ÅÎãπ',
                    'fast': 'Îπ†Î¶Ñ',
                    'very_fast': 'Îß§Ïö∞ Îπ†Î¶Ñ',
                    'no_data': 'Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå'
                };
                return labels[category] || 'Ïïå Ïàò ÏóÜÏùå';
            }
            
            getSpeechPatternLabel(pattern) {
                const labels = {
                    'staccato': 'ÎÅäÏñ¥ ÎßêÌïòÍ∏∞',
                    'continuous': 'Ïó∞ÏÜçÏ†Å',
                    'very_sparse': 'Îß§Ïö∞ ÎùÑÏóÑÎùÑÏóÑ',
                    'steady': 'ÏùºÏ†ïÌïú ÏÜçÎèÑ',
                    'variable': 'ÏÜçÎèÑ Î≥ÄÌôî ÌÅº',
                    'normal': 'ÏùºÎ∞òÏ†Å',
                    'no_data': 'Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå'
                };
                return labels[pattern] || 'Ïïå Ïàò ÏóÜÏùå';
            }
            
            async uploadFile() {
                const fileInput = document.getElementById('fileInput');
                const file = fileInput.files[0];
                
                if (!file) {
                    alert('ÌååÏùºÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                    return;
                }
                
                const formData = new FormData();
                formData.append('audio_file', file);
                
                const language = document.getElementById('languageSelect').value;
                const url = `http://localhost:8000/api/v1/stt/transcribe?scenario=${this.currentScenario}&language=${language}&return_timestamps=true`;
                
                try {
                    this.updateStatus('recording', 'ÌååÏùº Î∂ÑÏÑù Ï§ë...');
                    this.addLog('send', `ÌååÏùº ÏóÖÎ°úÎìú ÏãúÏûë: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB)`);
                    
                    const response = await fetch(url, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        this.addLog('receive', `ÌååÏùº Î∂ÑÏÑù ÏôÑÎ£å: "${result.text?.substring(0, 50)}${result.text?.length > 50 ? '...' : ''}"`);
                        this.displayFileResult(result);
                        this.updateStatus('connected', 'Î∂ÑÏÑù ÏôÑÎ£å');
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    console.error('ÌååÏùº ÏóÖÎ°úÎìú Ïò§Î•ò:', error);
                    this.addLog('info', `ÌååÏùº ÏóÖÎ°úÎìú Ïò§Î•ò: ${error.message}`);
                    alert('ÌååÏùº ÏóÖÎ°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
                    this.updateStatus('disconnected', 'Î∂ÑÏÑù Ïã§Ìå®');
                }
            }
            
            displayFileResult(data) {
                const container = document.getElementById('transcriptions');
                
                const resultDiv = document.createElement('div');
                resultDiv.className = 'transcription';
                
                resultDiv.innerHTML = `
                    <div>
                        <strong>üìÅ ÌååÏùº Î∂ÑÏÑù Í≤∞Í≥º:</strong> ${data.text}
                    </div>
                    <div style="margin-top: 10px; font-size: 12px; color: #666;">
                        Ïñ∏Ïñ¥: ${data.language} | Ï≤òÎ¶¨ ÏãúÍ∞Ñ: ${data.processing_time?.toFixed(2)}Ï¥à | Ïò§ÎîîÏò§ Í∏∏Ïù¥: ${data.duration?.toFixed(2)}Ï¥à
                    </div>
                `;
                
                container.appendChild(resultDiv);
                container.scrollTop = container.scrollHeight;
            }
            
            updateStatus(type, message) {
                const statusEl = document.getElementById('status');
                statusEl.className = `status ${type}`;
                statusEl.textContent = message;
            }
        }
        
        // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî
        const client = new RealtimeSTTClient();
        
        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ï¥àÍ∏∞ ÏÉÅÌÉú ÏÑ§Ï†ï
        window.addEventListener('load', () => {
            client.updateButtonStates();
        });
    </script>
</body>
</html> 